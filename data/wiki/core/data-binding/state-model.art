#[
  "title": "State Model"
  "layout": "docpage"
  "category": "Core > Data Binding"
  "tags": ["state", "model", "data", "core"]
  "body": {
    <h1>State Model</h1>

    <p>Vista maintains a state object that represents the current data values for all bound components. Understanding this model is key to building reactive applications.</p>

    <h2>State Structure</h2>

    <p>The state is a JavaScript object where each property corresponds to a bound word in your layout:</p>
    <pre><code>
    ; Arturo code
    counter: 0
    name: "Alice"
    accepted: false

    view [
        text counter
        field name
        checkbox accepted "Accept"
    ]

    ; Generates JavaScript state:
    state = {
        counter: 0,
        name: "Alice",
        accepted: false
    }
    </code></pre>

    <h2>State Types</h2>

    <h3>Primitive Values</h3>
    <pre><code>
    count: 42            ; Number
    name: "Text"         ; String
    active: true          ; Boolean
    value: null          ; Null
    </code></pre>

    <h3>Arrays and Lists</h3>
    <pre><code>
    items: ["A" "B" "C"]
    selection: [0 2]     ; Multi-select
    </code></pre>

    <h3>Mixed Values</h3>
    <pre><code>
    ; Radio groups
    color: "red"

    ; Tabs
    tabIndex: 1
    </code></pre>

    <h2>Setting State</h2>

    <h3>Via Actions</h3>
    <p>Button actions can modify state directly:</p>
    <pre><code>
    button "Increment" [counter: counter + 1]
    button "Set Name" [name: "New Name"]
    button "Toggle" [active: not active]
    </code></pre>

    <h3>Via set_state Function</h3>
    <pre><code>
    set_state "counter" 100
    set_state "name" "Updated"
    </code></pre>

    <h2>Reading State</h2>

    <p>State values are accessed directly in expressions:</p>
    <pre><code>
    ; In actions
    button "Double" [counter: counter * 2]

    ; In conditions
    if greater? counter 10 [
        text "Large number!"
    ]

    ; In computed values
    text ["Total: " price * quantity]
    </code></pre>

    <h2>State Change Detection</h2>

    <p>Vista detects state changes and triggers UI updates:</p>
    <pre><code>
    ; Enable change detection
    webview_sync_updates: true

    ; After modifying state
    counter: counter + 1
    sync_state
    </code></pre>

    <h2>Initial State</h2>

    <p>State is initialized from your Arturo variables:</p>
    <pre><code>
    ; Define before view()
    username: ""
    email: ""
    settings: #[darkMode: false notifications: true]

    view [
        field username
        input .type:"email" email
        toggle darkMode "Dark Mode"
    ]
    </code></pre>

    <h2>State Validation</h2>

    <p>You can validate state changes using on-change handlers:</p>
    <pre><code>
    field email .on-change:[
        if not equal? email "" [
            valid: contains? email "@"
        ]
    ]
    </code></pre>

    <h2>State Persistence</h2>

    <p>For persistent state, combine with storage:</p>
    <pre><code>
    ; Load on start
    if exists? "settings.json" [
        data: read "settings.json"
        settings: to :block data
    ]

    ; Save on change
    button "Save" [
        write "settings.json" to :string settings
    ]
    </code></pre>

    <h2>Best Practices</h2>

    <ul>
      <li>Define all bound variables before calling <code>view</code></li>
      <li>Use descriptive names for state variables</li>
      <li>Group related state into blocks or dictionaries</li>
      <li>Enable <code>webview_state_sync_ms</code> for automatic updates</li>
    </ul>

    <h2>See Also</h2>
    <ul>
      <li><a href="/wiki/core/data-binding/binding-overview/">Binding Overview</a> - Data binding concepts</li>
      <li><a href="/wiki/core/data-binding/two-way-binding/">Two-Way Binding</a> - Input binding</li>
      <li><a href="/wiki/core/concepts/state-management/">State Management</a> - State patterns</li>
    </ul>
  }
#]
