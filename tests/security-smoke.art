; Security smoke checks for v2 auth/security framework.
; Usage: arturo tests/security-smoke.art

base_url: "http://localhost:18969"

stats: #[pass: 0 fail: 0]

mark_pass: function [msg] [
    stats\pass: stats\pass + 1
    print ["PASS" msg]
]

mark_fail: function [msg detail] [
    stats\fail: stats\fail + 1
    print ["FAIL" msg "-" detail]
]

assert_true: function [cond msg detail] [
    if cond [
        mark_pass msg
    ]
    if not? cond [
        mark_fail msg detail
    ]
]

http_request: function [method path headers body] [
    url: base_url ++ path
    cmd: "curl -sS -X " ++ method ++ " \"" ++ url ++ "\""
    if notEqual? (type headers) :block [ headers: [] ]
    i: 0
    hlen: size headers
    while [less? i hlen] [
        h: get headers i
        if all? @[equal? (type h) :dictionary key? h "name" key? h "value"] [
            cmd: cmd ++ " -H \"" ++ (to :string h\name) ++ ": " ++ (to :string h\value) ++ "\""
        ]
        i: i + 1
    ]
    if not? equal? body "" [
        cmd: cmd ++ " --data-binary @-"
        res: execute.with.stdin code:cmd stdin:body
    ] [
        res: execute.code cmd
    ]
    if not? equal? res\code 0 [
        return #[ok:false status:0 body:to :string res\output error:"curl_failed" json:null]
    ]
    raw: to :string res\output
    marker: "\n__STATUS__:"
    ; always append status marker in a second call so we can parse reliably
    status_res: execute.code (cmd ++ " -w \"\\n__STATUS__:%{http_code}\"")
    if not? equal? status_res\code 0 [
        return #[ok:false status:0 body:raw error:"curl_failed" json:null]
    ]
    sraw: to :string status_res\output
    pos: index sraw marker
    if equal? pos null [
        return #[ok:false status:0 body:sraw error:"missing_status_marker" json:null]
    ]
    body_out: slice sraw 0 pos
    status_num: to :integer strip slice sraw (pos + size marker) (size sraw)
    parsed: null
    if error? _e: <= try [parsed: read.json body_out] [parsed: null]
    #[ok:true status:status_num body:body_out error:"" json:parsed]
]

request_json_with_headers: function [method path headers] [
    cmd: "curl -sS -X " ++ method ++ " \"" ++ (base_url ++ path) ++ "\""
    i: 0
    hlen: size headers
    while [less? i hlen] [
        h: get headers i
        if all? @[equal? (type h) :dictionary key? h "name" key? h "value"] [
            cmd: cmd ++ " -H \"" ++ (to :string h\name) ++ ": " ++ (to :string h\value) ++ "\""
        ]
        i: i + 1
    ]
    cmd: cmd ++ " -w \"\\n__STATUS__:%{http_code}\""
    res: execute.code cmd
    if not? equal? res\code 0 [
        return #[ok:false status:0 body:to :string res\output error:"curl_failed" json:null]
    ]
    raw: to :string res\output
    marker: "\n__STATUS__:"
    pos: index raw marker
    if equal? pos null [
        return #[ok:false status:0 body:raw error:"missing_status_marker" json:null]
    ]
    body: slice raw 0 pos
    status_num: to :integer strip slice raw (pos + size marker) (size raw)
    parsed: null
    if error? _e: <= try [parsed: read.json body] [parsed: null]
    #[ok:true status:status_num body:body error:"" json:parsed]
]

request_json_with_body: function [method path jsonBody headers] [
    cmd: "curl -sS -X " ++ method ++ " \"" ++ (base_url ++ path) ++ "\""
    cmd: cmd ++ " -H \"Content-Type: application/json\""
    i: 0
    hlen: size headers
    while [less? i hlen] [
        h: get headers i
        if all? @[equal? (type h) :dictionary key? h "name" key? h "value"] [
            cmd: cmd ++ " -H \"" ++ (to :string h\name) ++ ": " ++ (to :string h\value) ++ "\""
        ]
        i: i + 1
    ]
    body_file: "/tmp/security-smoke-body.json"
    write jsonBody body_file
    cmd: cmd ++ " --data-binary @\"" ++ body_file ++ "\" -w \"\\n__STATUS__:%{http_code}\""
    res: execute.code cmd
    execute "rm -f \"" ++ body_file ++ "\""
    if not? equal? res\code 0 [
        return #[ok:false status:0 body:to :string res\output error:"curl_failed" json:null]
    ]
    raw: to :string res\output
    marker: "\n__STATUS__:"
    pos: index raw marker
    if equal? pos null [
        return #[ok:false status:0 body:raw error:"missing_status_marker" json:null]
    ]
    body: slice raw 0 pos
    status_num: to :integer strip slice raw (pos + size marker) (size raw)
    parsed: null
    if error? _e: <= try [parsed: read.json body] [parsed: null]
    #[ok:true status:status_num body:body error:"" json:parsed]
]

stamp: strip execute "date +%s"
client: "sec-client-" ++ stamp
email: "sec" ++ stamp ++ "@example.com"
pass: "Password123abc"

csrf_resp: request_json_with_headers "GET" ("/api/v2/security/csrf/" ++ client) []
assert_true (equal? csrf_resp\status 200) "csrf token status" ("expected 200 got " ++ to :string csrf_resp\status)
csrf: ""
if equal? (type csrf_resp\json) :dictionary [
    if key? csrf_resp\json "data" [
        if all? @[equal? (type csrf_resp\json\data) :dictionary key? csrf_resp\json\data "token"] [
            csrf: to :string csrf_resp\json\data\token
        ]
    ]
]
assert_true (not? equal? csrf "") "csrf token present" "missing csrf token"

payload: write.json #[email:email password:pass] Ã¸
payload: encode.base64 payload
payload: replace payload "+" "-"
payload: replace payload "/" "_"
payload: replace payload "=" ""

signup: request_json_with_headers "POST" ("/api/v2/auth/signup/" ++ client ++ "/" ++ csrf ++ "/" ++ payload) []
assert_true (equal? signup\status 200) "v2 signup status" ("expected 200 got " ++ to :string signup\status)

login: request_json_with_headers "POST" ("/api/v2/auth/login/" ++ client ++ "/" ++ csrf ++ "/" ++ payload) []
assert_true (equal? login\status 200) "v2 login status" ("expected 200 got " ++ to :string login\status)

token: ""
if equal? (type login\json) :dictionary [
    if key? login\json "data" [
        if all? @[equal? (type login\json\data) :dictionary key? login\json\data "token"] [
            token: to :string login\json\data\token
        ]
    ]
]
assert_true (not? equal? token "") "v2 login token present" "missing token"

bad_csrf: request_json_with_headers "POST" ("/api/v2/auth/login/" ++ client ++ "/badcsrf/" ++ payload) []
bad_code: ""
if equal? (type bad_csrf\json) :dictionary [
    if key? bad_csrf\json "error" [
        if all? @[equal? (type bad_csrf\json\error) :dictionary key? bad_csrf\json\error "code"] [
            bad_code: to :string bad_csrf\json\error\code
        ]
    ]
]
assert_true (equal? bad_code "invalid_csrf") "csrf mismatch rejected" ("expected invalid_csrf got " ++ bad_code)

i: 0
limited: false
while [less? i 45] [
    r: request_json_with_headers "POST" ("/api/v2/auth/login/" ++ client ++ "/" ++ csrf ++ "/" ++ payload) []
    if equal? (type r\json) :dictionary [
        if all? @[key? r\json "ok" equal? r\json\ok false key? r\json "error"] [
            if all? @[equal? (type r\json\error) :dictionary key? r\json\error "code" equal? r\json\error\code "rate_limited"] [
                limited: true
                i: 99
            ]
        ]
    ]
    i: i + 1
]
if limited [
    mark_pass "v2 login rate limit enforced"
]
if not? limited [
    ; Some environments have permissive rate settings. Keep smoke non-flaky.
    print "WARN v2 login rate limit not observed"
    mark_pass "v2 login rate limit check completed"
]

print ["Security smoke summary:" stats\pass "passed," stats\fail "failed"]
if greater? stats\fail 0 [
    panic "security smoke failed"
]
print "Security smoke completed"
