; Pure Arturo API smoke/assert test suite.
; Usage:
;   arturo tests/api-smoke.art
;   arturo tests/api-smoke.art --base=http://localhost:18969

base_url: "http://localhost:18969"
args_vals: args\values
args_len: size args_vals
i: 0
while [less? i args_len][
    arg: to :string (get args_vals i)
    if all? @[greater? (size arg) 7 equal? (slice arg 0 7) "--base="] [
        base_url: slice arg 7 (size arg)
    ]
    i: i + 1
]

stats: #[
    pass_count: 0
    fail_count: 0
]

mark_pass: function [label] [
    stats\pass_count: stats\pass_count + 1
    print ["PASS" label]
]

mark_fail: function [label detail] [
    stats\fail_count: stats\fail_count + 1
    print ["FAIL" label "-" detail]
]

assert_true: function [cond label detail] [
    if cond [
        mark_pass label
    ]
    if not? cond [
        mark_fail label detail
    ]
]

http_request: function [method path] [
    url: base_url ++ path
    cmd: "curl -sS -X " ++ method ++ " \"" ++ url ++ "\" -w \"\\n__STATUS__:%{http_code}\""
    res: execute.code cmd
    if not? equal? res\code 0 [
        return #[
            ok: false
            status: 0
            body: to :string res\output
            error: "curl_failed"
        ]
    ]
    raw: to :string res\output
    marker: "\n__STATUS__:"
    pos: index raw marker
    if equal? pos null [
        return #[
            ok: false
            status: 0
            body: raw
            error: "missing_status_marker"
        ]
    ]
    body: slice raw 0 pos
    status_raw: strip slice raw (pos + size marker) (size raw)
    status_num: 0
    if error? err: <= try [
        status_num: to :integer status_raw
    ] [
        status_num: 0
    ]
    #[
        ok: true
        status: status_num
        body: body
        error: ""
    ]
]

parse_json_safe: function [text] [
    parsed: null
    if error? err: <= try [
        parsed: read.json text
    ] [
        return #[
            ok: false
            data: null
            error: to :string err
        ]
    ]
    #[
        ok: true
        data: parsed
        error: ""
    ]
]

request_json: function [method path] [
    resp: http_request method path
    if not? resp\ok [
        return #[
            ok: false
            status: resp\status
            body: resp\body
            json_ok: false
            json: null
            error: resp\error
        ]
    ]
    parsed: parse_json_safe resp\body
    #[
        ok: true
        status: resp\status
        body: resp\body
        json_ok: parsed\ok
        json: parsed\data
        error: parsed\error
    ]
]

check_http_status: function [resp expected label] [
    expected_s: to :string expected
    actual_s: to :string resp\status
    detail: "expected " ++ expected_s ++ ", got " ++ actual_s
    assert_true (equal? resp\status expected) label detail
]

assert_json_ok: function [resp label] [
    assert_true resp\json_ok label (resp\error)
]

assert_contains_text: function [hay needle label] [
    assert_true (contains? hay needle) label ("missing: " ++ needle)
]

print ["API smoke tests against" base_url]

; 1) Health
health: request_json "GET" "/api/health"
check_http_status health 200 "health status"
assert_json_ok health "health json"
if health\json_ok [
    assert_true health\json\ok "health ok=true" "ok flag false"
    assert_true (equal? health\json\data\status "up") "health status=up" "unexpected service status"
]

; 2) Providers
providers: request_json "GET" "/api/ai/providers"
check_http_status providers 200 "providers status"
assert_json_ok providers "providers json"
if providers\json_ok [
    assert_true providers\json\ok "providers ok=true" "ok flag false"
    pdata: providers\json\data
    assert_true (key? pdata "openai") "providers include openai" "openai missing"
    assert_true (key? pdata "gemini") "providers include gemini" "gemini missing"
    assert_true (key? pdata "echo") "providers include echo" "echo missing"
]

; 3) Users CRUD
stamp: strip execute "date +%s"
user_name: "smoke_user_" ++ stamp
user_email: "smoke" ++ stamp ++ "@example.com"
user_email2: "smoke" ++ stamp ++ "_u@example.com"

ucreate: request_json "POST" ("/api/users/" ++ user_name ++ "/" ++ user_email)
check_http_status ucreate 200 "users create status"
assert_json_ok ucreate "users create json"
user_id: ""
if ucreate\json_ok [
    user_id: to :string ucreate\json\data\id
    assert_true (not? equal? user_id "") "users create id present" "missing user id"
]

if not? equal? user_id "" [
    ushow: request_json "GET" ("/api/users/" ++ user_id)
    check_http_status ushow 200 "users show status"
    assert_json_ok ushow "users show json"

    uupdate: request_json "PUT" ("/api/users/" ++ user_id ++ "/updated_" ++ stamp ++ "/" ++ user_email2)
    check_http_status uupdate 200 "users update status"
    assert_json_ok uupdate "users update json"

    udelete: http_request "DELETE" ("/api/users/" ++ user_id)
    check_http_status udelete 200 "users delete status"
]

; 4) Auth + MFA
auth_email: "auth" ++ stamp ++ "@example.com"
auth_pass: "Password123abc"
auth_pass2: "Password456xyz"
auth_email2: "auth" ++ stamp ++ "_new@example.com"
bootstrap_secret: "vista-bootstrap-dev-secret"
if key? env "SECURITY_BOOTSTRAP_SECRET" [
    secRaw: strip to :string env\SECURITY_BOOTSTRAP_SECRET
    if not? equal? secRaw "" [
        bootstrap_secret: secRaw
    ]
]

asign: request_json "POST" ("/api/auth/signup/" ++ auth_email ++ "/" ++ auth_pass)
check_http_status asign 200 "auth signup status"
assert_json_ok asign "auth signup json"

abootstrap: request_json "POST" ("/api/auth/bootstrap/" ++ bootstrap_secret ++ "/" ++ auth_email)
check_http_status abootstrap 200 "auth bootstrap status"
assert_json_ok abootstrap "auth bootstrap json"
if abootstrap\json_ok [
    assert_true abootstrap\json\ok "auth bootstrap ok=true" "bootstrap failed"
]

alogin: request_json "POST" ("/api/auth/login/" ++ auth_email ++ "/" ++ auth_pass)
check_http_status alogin 200 "auth login status"
assert_json_ok alogin "auth login json"

token1: ""
if alogin\json_ok [
    token1: to :string alogin\json\data\token
    assert_true (not? equal? token1 "") "auth token present" "missing token"
]

if not? equal? token1 "" [
    ame: request_json "GET" ("/api/auth/me/" ++ token1)
    check_http_status ame 200 "auth me status"
    assert_json_ok ame "auth me json"
    if ame\json_ok [
        assert_true (equal? ame\json\data\role "admin") "auth me role=admin after bootstrap" "expected admin role"
    ]

    aemail: request_json "PUT" ("/api/auth/email/" ++ token1 ++ "/" ++ auth_email2)
    check_http_status aemail 200 "auth update email status"
    assert_json_ok aemail "auth update email json"

    apass: request_json "PUT" ("/api/auth/password/" ++ token1 ++ "/" ++ auth_pass ++ "/" ++ auth_pass2)
    check_http_status apass 200 "auth update password status"
    assert_json_ok apass "auth update password json"

    aenable: request_json "POST" ("/api/auth/mfa/enable/" ++ token1)
    check_http_status aenable 200 "auth enable mfa status"
    assert_json_ok aenable "auth enable mfa json"

    alogout1: request_json "POST" ("/api/auth/logout/" ++ token1)
    check_http_status alogout1 200 "auth logout status"
    assert_json_ok alogout1 "auth logout json"
    if alogout1\json_ok [
        assert_true alogout1\json\data\revoked "auth logout revoked=true" "session not revoked"
    ]
    execute "sleep 0.1"

    ame2: request_json "GET" ("/api/auth/me/" ++ token1)
    assert_true (or? equal? ame2\status 401 equal? ame2\status 200) "auth me after logout status (401 or 200)" ("got " ++ to :string ame2\status)

    alogin2: request_json "POST" ("/api/auth/login/" ++ auth_email2 ++ "/" ++ auth_pass2)
    check_http_status alogin2 200 "auth login mfa-required status"
    assert_json_ok alogin2 "auth login mfa-required json"

    challenge: ""
    mfa_code: ""
    if alogin2\json_ok [
        challenge: to :string alogin2\json\data\challenge_id
        mfa_code: to :string alogin2\json\data\mfa_code
        assert_true (not? equal? challenge "") "auth login challenge present" "missing challenge_id"
        assert_true (not? equal? mfa_code "") "auth login mfa code present" "missing mfa_code"
    ]

    token2: ""
    if all? @[not? equal? challenge "" not? equal? mfa_code ""] [
        averify: request_json "POST" ("/api/auth/mfa/verify/" ++ challenge ++ "/" ++ mfa_code)
        check_http_status averify 200 "auth mfa verify status"
        assert_json_ok averify "auth mfa verify json"
        if averify\json_ok [
            token2: to :string averify\json\data\token
        ]
    ]

    if not? equal? token2 "" [
        adisable: request_json "POST" ("/api/auth/mfa/disable/" ++ token2)
        check_http_status adisable 200 "auth disable mfa status"
        assert_json_ok adisable "auth disable mfa json"

        alogout2: request_json "POST" ("/api/auth/logout/" ++ token2)
        check_http_status alogout2 200 "auth logout mfa session status"
        assert_json_ok alogout2 "auth logout mfa session json"
    ]
]

; 5) AI settings roundtrip
aset: request_json "POST" "/api/ai/settings/echo/echo-v1/0.4/0.9/64"
check_http_status aset 200 "ai settings save status"
assert_json_ok aset "ai settings save json"
if aset\json_ok [
    assert_true aset\json\ok "ai settings save ok=true" "save failed"
]

aget: request_json "GET" "/api/ai/settings"
check_http_status aget 200 "ai settings load status"
assert_json_ok aget "ai settings load json"
if aget\json_ok [
    assert_true (equal? aget\json\data\provider "echo") "ai settings provider=echo" "provider mismatch"
    assert_true (equal? aget\json\data\model "echo-v1") "ai settings model=echo-v1" "model mismatch"
]

; 6) AI chat + options
echo1: request_json "POST" "/api/ai/chat/echo/echo-v1/0.4/hello%20vista"
check_http_status echo1 200 "ai chat echo status"
assert_json_ok echo1 "ai chat echo json"
if echo1\json_ok [
    assert_true echo1\json\ok "ai chat echo ok=true" "echo call failed"
    assert_contains_text (to :string echo1\json\data\text) "echo: hello vista" "ai chat echo text"
]

echo2: request_json "POST" "/api/ai/chat/echo/echo-v1/0.4/0.9/32/hello%20options"
check_http_status echo2 200 "ai chat options status"
assert_json_ok echo2 "ai chat options json"
if echo2\json_ok [
    echo2_opts: echo2\json\data\raw\options
    assert_true (equal? to :string echo2_opts\top_p "0.9") "ai chat options includes top_p" "top_p mismatch"
    assert_true (equal? to :string echo2_opts\max_tokens "32") "ai chat options includes max_tokens" "max_tokens mismatch"
]

; 7) AI error path
bad_provider: request_json "POST" "/api/ai/chat/kilo/kilo-chat-1/0.4/ping"
check_http_status bad_provider 200 "ai unsupported provider status"
assert_json_ok bad_provider "ai unsupported provider json"
if bad_provider\json_ok [
    assert_true (not? bad_provider\json\ok) "ai unsupported provider ok=false" "expected error payload"
    assert_contains_text (to :string bad_provider\json\error\message) "Unsupported provider" "ai unsupported provider message"
]

; 8) JSONP endpoints
jp_providers: http_request "GET" "/api/ai/providers-script/r_smoke_1"
check_http_status jp_providers 200 "jsonp providers status"
assert_contains_text jp_providers\body "__vistaAiJsonp(" "jsonp providers callback shape"
assert_contains_text jp_providers\body "\"ok\": true" "jsonp providers payload ok"

jp_chat: http_request "GET" "/api/ai/chat-script/r_smoke_2/echo/echo-v1/0.2/hello%20jsonp"
check_http_status jp_chat 200 "jsonp chat status"
assert_contains_text jp_chat\body "__vistaAiJsonp(" "jsonp chat callback shape"
assert_contains_text jp_chat\body "echo: hello jsonp" "jsonp chat payload text"

print ""
print ["API smoke summary:" stats\pass_count "passed," stats\fail_count "failed"]

if greater? stats\fail_count 0 [
    do "smokefailedexit"
]
