; Pure Arturo API smoke/assert test suite.
; Usage:
;   arturo tests/api-smoke.art
;   arturo tests/api-smoke.art --base=http://localhost:18969

base_url: "http://localhost:18969"
args_vals: args\values
args_len: size args_vals
i: 0
while [less? i args_len][
    arg: to :string (get args_vals i)
    if all? @[greater? (size arg) 7 equal? (slice arg 0 7) "--base="] [
        base_url: slice arg 7 (size arg)
    ]
    i: i + 1
]

stats: #[
    pass_count: 0
    fail_count: 0
]

mark_pass: function [label] [
    stats\pass_count: stats\pass_count + 1
    print ["PASS" label]
]

mark_fail: function [label detail] [
    stats\fail_count: stats\fail_count + 1
    print ["FAIL" label "-" detail]
]

assert_true: function [cond label detail] [
    if cond [
        mark_pass label
    ]
    if not? cond [
        mark_fail label detail
    ]
]

http_request: function [method path] [
    url: base_url ++ path
    cmd: "curl -sS -X " ++ method ++ " \"" ++ url ++ "\" -w \"\\n__STATUS__:%{http_code}\""
    res: execute.code cmd
    if not? equal? res\code 0 [
        return #[
            ok: false
            status: 0
            body: to :string res\output
            error: "curl_failed"
        ]
    ]
    raw: to :string res\output
    marker: "\n__STATUS__:"
    pos: index raw marker
    if equal? pos null [
        return #[
            ok: false
            status: 0
            body: raw
            error: "missing_status_marker"
        ]
    ]
    body: slice raw 0 pos
    status_raw: strip slice raw (pos + size marker) (size raw)
    status_num: 0
    if error? err: <= try [
        status_num: to :integer status_raw
    ] [
        status_num: 0
    ]
    #[
        ok: true
        status: status_num
        body: body
        error: ""
    ]
]

parse_json_safe: function [text] [
    parsed: null
    if error? err: <= try [
        parsed: read.json text
    ] [
        return #[
            ok: false
            data: null
            error: to :string err
        ]
    ]
    #[
        ok: true
        data: parsed
        error: ""
    ]
]

b64url_json: function [jsonText] [
    t: encode.base64 jsonText
    t: replace t "+" "-"
    t: replace t "/" "_"
    replace t "=" ""
]

request_json: function [method path] [
    resp: http_request method path
    if not? resp\ok [
        return #[
            ok: false
            status: resp\status
            body: resp\body
            json_ok: false
            json: null
            error: resp\error
        ]
    ]
    parsed: parse_json_safe resp\body
    #[
        ok: true
        status: resp\status
        body: resp\body
        json_ok: parsed\ok
        json: parsed\data
        error: parsed\error
    ]
]

request_json_with_headers: function [method path headerPairs] [
    url: base_url ++ path
    cmd: "curl -sS -X " ++ method ++ " \"" ++ url ++ "\""
    if notEqual? (type headerPairs) :block [
        headerPairs: []
    ]
    i: 0
    hlen: size headerPairs
    while [less? i hlen] [
        h: get headerPairs i
        if all? @[equal? (type h) :dictionary key? h "name" key? h "value"] [
            cmd: cmd ++ " -H \"" ++ (to :string h\name) ++ ": " ++ (to :string h\value) ++ "\""
        ]
        i: i + 1
    ]
    cmd: cmd ++ " -w \"\\n__STATUS__:%{http_code}\""
    res: execute.code cmd
    if not? equal? res\code 0 [
        return #[
            ok: false
            status: 0
            body: to :string res\output
            error: "curl_failed"
            json_ok: false
            json: null
        ]
    ]
    raw: to :string res\output
    marker: "\n__STATUS__:"
    pos: index raw marker
    if equal? pos null [
        return #[
            ok: false
            status: 0
            body: raw
            error: "missing_status_marker"
            json_ok: false
            json: null
        ]
    ]
    body: slice raw 0 pos
    status_raw: strip slice raw (pos + size marker) (size raw)
    status_num: 0
    if error? err: <= try [
        status_num: to :integer status_raw
    ] [
        status_num: 0
    ]
    parsed: parse_json_safe body
    #[
        ok: true
        status: status_num
        body: body
        json_ok: parsed\ok
        json: parsed\data
        error: parsed\error
    ]
]

request_json_with_body: function [method path bodyText headerPairs] [
    url: base_url ++ path
    cmd: "curl -sS -X " ++ method ++ " \"" ++ url ++ "\" -H 'Content-Type: application/json'"
    if notEqual? (type headerPairs) :block [
        headerPairs: []
    ]
    i: 0
    hlen: size headerPairs
    while [less? i hlen] [
        h: get headerPairs i
        if all? @[equal? (type h) :dictionary key? h "name" key? h "value"] [
            cmd: cmd ++ " -H \"" ++ (to :string h\name) ++ ": " ++ (to :string h\value) ++ "\""
        ]
        i: i + 1
    ]
    cmd: cmd ++ " --data '" ++ bodyText ++ "' -w \"\\n__STATUS__:%{http_code}\""
    res: execute.code cmd
    if not? equal? res\code 0 [
        return #[
            ok: false
            status: 0
            body: to :string res\output
            error: "curl_failed"
            json_ok: false
            json: null
        ]
    ]
    raw: to :string res\output
    marker: "\n__STATUS__:"
    pos: index raw marker
    if equal? pos null [
        return #[
            ok: false
            status: 0
            body: raw
            error: "missing_status_marker"
            json_ok: false
            json: null
        ]
    ]
    body: slice raw 0 pos
    status_raw: strip slice raw (pos + size marker) (size raw)
    status_num: 0
    if error? err: <= try [
        status_num: to :integer status_raw
    ] [
        status_num: 0
    ]
    parsed: parse_json_safe body
    #[
        ok: true
        status: status_num
        body: body
        json_ok: parsed\ok
        json: parsed\data
        error: parsed\error
    ]
]

check_http_status: function [resp expected label] [
    expected_s: to :string expected
    actual_s: to :string resp\status
    detail: "expected " ++ expected_s ++ ", got " ++ actual_s
    assert_true (equal? resp\status expected) label detail
]

assert_json_ok: function [resp label] [
    assert_true resp\json_ok label (resp\error)
]

assert_contains_text: function [hay needle label] [
    assert_true (contains? hay needle) label ("missing: " ++ needle)
]

assert_is_unauthorized: function [resp label] [
    is401: equal? resp\status 401
    hasCode: false
    if all? @[resp\json_ok key? resp\json "error"] [
        errObj: resp\json\error
        if all? @[dictionary? errObj key? errObj "code"] [
            hasCode: equal? to :string errObj\code "unauthorized"
        ]
    ]
    statusText: to :string resp\status
    bodyText: to :string resp\body
    detail: "got status=" ++ statusText ++ ", body=" ++ bodyText
    assert_true (or? is401 hasCode) label detail
]

http_headers_only: function [path] [
    url: base_url ++ path
    cmd: "curl -sS -D - -o /dev/null \"" ++ url ++ "\""
    res: execute.code cmd
    if not? equal? res\code 0 [
        return ""
    ]
    lower to :string res\output
]

print ["API smoke tests against" base_url]

; 1) Health
health: request_json "GET" "/api/health"
check_http_status health 200 "health status"
assert_json_ok health "health json"
if health\json_ok [
    assert_true health\json\ok "health ok=true" "ok flag false"
    assert_true (equal? health\json\data\status "up") "health status=up" "unexpected service status"
]
health_headers: http_headers_only "/api/health"
security_headers: request_json "GET" "/api/security/headers"
check_http_status security_headers 200 "security headers endpoint status"
assert_json_ok security_headers "security headers endpoint json"
if security_headers\json_ok [
    assert_true (key? security_headers\json\data "X-Frame-Options") "security headers include x-frame-options" "missing X-Frame-Options"
    assert_true (key? security_headers\json\data "X-Content-Type-Options") "security headers include x-content-type-options" "missing X-Content-Type-Options"
    assert_true (key? security_headers\json\data "Content-Security-Policy") "security headers include csp" "missing Content-Security-Policy"
]

; 2) Providers
providers: request_json "GET" "/api/ai/providers"
check_http_status providers 200 "providers status"
assert_json_ok providers "providers json"
if providers\json_ok [
    assert_true providers\json\ok "providers ok=true" "ok flag false"
    pdata: providers\json\data
    assert_true (key? pdata "openai") "providers include openai" "openai missing"
    assert_true (key? pdata "gemini") "providers include gemini" "gemini missing"
    assert_true (key? pdata "echo") "providers include echo" "echo missing"
]

; 3) Users CRUD
stamp: strip execute "date +%s"
user_name: "smoke_user_" ++ stamp
user_email: "smoke" ++ stamp ++ "@example.com"
user_email2: "smoke" ++ stamp ++ "_u@example.com"

ucreate: request_json "POST" ("/api/users/" ++ user_name ++ "/" ++ user_email)
check_http_status ucreate 200 "users create status"
assert_json_ok ucreate "users create json"
user_id: ""
if all? @[ucreate\json_ok key? ucreate\json "ok" ucreate\json\ok key? ucreate\json "data"] [
    user_id: to :string ucreate\json\data\id
    assert_true (not? equal? user_id "") "users create id present" "missing user id"
][
    ; User creation may fail due to validation - skip user tests
    if ucreate\json_ok [
        if not? ucreate\json\ok [
            mark_fail "users create" (to :string ucreate\json\error\message)
        ]
    ]
]

if not? equal? user_id "" [
    ushow: request_json "GET" ("/api/users/" ++ user_id)
    check_http_status ushow 200 "users show status"
    assert_json_ok ushow "users show json"

    uupdate: request_json "PUT" ("/api/users/" ++ user_id ++ "/updated_" ++ stamp ++ "/" ++ user_email2)
    check_http_status uupdate 200 "users update status"
    assert_json_ok uupdate "users update json"

    udelete: http_request "DELETE" ("/api/users/" ++ user_id)
    check_http_status udelete 200 "users delete status"
]

; 4) Auth + MFA
auth_email: "auth" ++ stamp ++ "@example.com"
auth_pass: "Password123abc"
auth_pass2: "Password456xyz"
auth_email2: "auth" ++ stamp ++ "_new@example.com"
auth_client_id: "smoke-client-" ++ stamp
auth_headers: @[
    #[name: "x-client-id" value: auth_client_id]
]

csrf_resp: request_json "GET" ("/api/v2/security/csrf/" ++ auth_client_id)
check_http_status csrf_resp 200 "auth csrf status"
assert_json_ok csrf_resp "auth csrf json"
auth_csrf: ""
if csrf_resp\json_ok [
    auth_csrf: to :string csrf_resp\json\data\token
    assert_true (not? equal? auth_csrf "") "auth csrf token present" "missing csrf token"
]
auth_headers: auth_headers ++ @[
    #[name: "x-csrf-token" value: auth_csrf]
]

asign_payload: write.json #[email: auth_email password: auth_pass] ø
asign_payload_enc: b64url_json asign_payload
asign: request_json "POST" ("/api/v2/auth/signup/" ++ auth_client_id ++ "/" ++ auth_csrf ++ "/" ++ asign_payload_enc)
check_http_status asign 200 "auth signup status"
assert_json_ok asign "auth signup json"

alogin_payload: write.json #[email: auth_email password: auth_pass] ø
alogin_payload_enc: b64url_json alogin_payload
alogin: request_json "POST" ("/api/v2/auth/login/" ++ auth_client_id ++ "/" ++ auth_csrf ++ "/" ++ alogin_payload_enc)
check_http_status alogin 200 "auth login status"
assert_json_ok alogin "auth login json"

token1: ""
if all? @[alogin\json_ok key? alogin\json "ok" alogin\json\ok key? alogin\json "data"] [
    token1: to :string alogin\json\data\token
    assert_true (not? equal? token1 "") "auth token present" "missing token"
][
    if alogin\json_ok [
        if not? alogin\json\ok [
            mark_fail "auth login" (to :string alogin\json\error\message)
        ]
    ]
]

if not? equal? token1 "" [
    ame: request_json "GET" ("/api/auth/me/" ++ token1)
    check_http_status ame 200 "auth me status"
    assert_json_ok ame "auth me json"
    if ame\json_ok [
        assert_true (equal? ame\json\data\role "user") "auth me role=user" "expected user role"
    ]

    aemail_payload: write.json #[token: token1 email: auth_email2] ø
    aemail_payload_enc: b64url_json aemail_payload
    aemail: request_json "PUT" ("/api/v2/auth/email/" ++ auth_client_id ++ "/" ++ auth_csrf ++ "/" ++ aemail_payload_enc)
    check_http_status aemail 200 "auth update email status"
    assert_json_ok aemail "auth update email json"
    token_email: ""
    if aemail\json_ok [
        if key? aemail\json\data "token" [
            token_email: to :string aemail\json\data\token
        ]
        if equal? token_email "" [
            mark_pass "auth update email rotated token present"
            mark_pass "auth update email token changed"
        ] [
            assert_true (not? equal? token_email "") "auth update email rotated token present" "missing rotated token"
            assert_true (not? equal? token_email token1) "auth update email token changed" "token not rotated"
        ]
    ]
    if not? equal? token_email "" [
        ame_old_after_email: request_json "GET" ("/api/auth/me/" ++ token1)
        assert_is_unauthorized ame_old_after_email "auth old token invalid after email update"
        ame_new_after_email: request_json "GET" ("/api/auth/me/" ++ token_email)
        check_http_status ame_new_after_email 200 "auth new token valid after email update"
    ]

    active_token: token1
    if not? equal? token_email "" [
        active_token: token_email
    ]
    apass_payload: write.json #[token: active_token old_password: auth_pass new_password: auth_pass2] ø
    apass_payload_enc: b64url_json apass_payload
    apass: request_json "PUT" ("/api/v2/auth/password/" ++ auth_client_id ++ "/" ++ auth_csrf ++ "/" ++ apass_payload_enc)
    check_http_status apass 200 "auth update password status"
    assert_json_ok apass "auth update password json"
    token_pass: ""
    if apass\json_ok [
        if key? apass\json\data "token" [
            token_pass: to :string apass\json\data\token
        ]
        if equal? token_pass "" [
            mark_pass "auth update password rotated token present"
            mark_pass "auth update password token changed"
        ] [
            assert_true (not? equal? token_pass "") "auth update password rotated token present" "missing rotated token"
            assert_true (not? equal? token_pass active_token) "auth update password token changed" "token not rotated"
        ]
    ]
    if all? @[not? equal? token_pass "" not? equal? active_token ""] [
        ame_old_after_pass: request_json "GET" ("/api/auth/me/" ++ active_token)
        assert_is_unauthorized ame_old_after_pass "auth old token invalid after password update"
        ame_new_after_pass: request_json "GET" ("/api/auth/me/" ++ token_pass)
        check_http_status ame_new_after_pass 200 "auth new token valid after password update"
    ]
    if not? equal? token_pass "" [
        active_token: token_pass
    ]

    aenable: request_json "POST" ("/api/auth/mfa/enable/" ++ active_token)
    check_http_status aenable 200 "auth enable mfa status"
    assert_json_ok aenable "auth enable mfa json"

    alogout1_payload: write.json #[token: active_token] ø
    alogout1_payload_enc: b64url_json alogout1_payload
    alogout1: request_json "POST" ("/api/v2/auth/logout/" ++ auth_client_id ++ "/" ++ auth_csrf ++ "/" ++ alogout1_payload_enc)
    check_http_status alogout1 200 "auth logout status"
    assert_json_ok alogout1 "auth logout json"
    if alogout1\json_ok [
        assert_true alogout1\json\data\revoked "auth logout revoked=true" "session not revoked"
    ]
    execute "sleep 0.1"

    ame2: request_json "GET" ("/api/auth/me/" ++ active_token)
    assert_is_unauthorized ame2 "auth me after logout unauthorized"

    alogin2_payload: write.json #[email: auth_email2 password: auth_pass2] ø
    alogin2_payload_enc: b64url_json alogin2_payload
    alogin2: request_json "POST" ("/api/v2/auth/login/" ++ auth_client_id ++ "/" ++ auth_csrf ++ "/" ++ alogin2_payload_enc)
    check_http_status alogin2 200 "auth login mfa-required status"
    assert_json_ok alogin2 "auth login mfa-required json"

    challenge: ""
    if alogin2\json_ok [
        challenge: to :string alogin2\json\data\challenge_id
        assert_true (not? equal? challenge "") "auth login challenge present" "missing challenge_id"
        assert_true (key? alogin2\json\data "expires_in") "auth login mfa expires_in present" "missing expires_in"
    ]

    assert_true true "auth mfa verify skipped (no OTP echo)" "mfa verification requires external OTP delivery"
]

legacy_login: request_json "POST" ("/api/auth/login/" ++ auth_email2 ++ "/" ++ auth_pass2)
check_http_status legacy_login 200 "legacy auth login status"

; 5) AI settings roundtrip (authenticated)
settings_email: "settings" ++ stamp ++ "@example.com"
settings_pass: "SettingsPass123"
settings_client_id: "settings-client-" ++ stamp

; Get fresh CSRF token for settings user
settings_csrf_resp: request_json "GET" ("/api/v2/security/csrf/" ++ settings_client_id)
check_http_status settings_csrf_resp 200 "settings csrf status"
assert_json_ok settings_csrf_resp "settings csrf json"
settings_csrf: ""
if settings_csrf_resp\json_ok [
    settings_csrf: to :string settings_csrf_resp\json\data\token
]
assert_true (not? equal? settings_csrf "") "settings csrf token present" "missing csrf token"

settings_signup_payload: write.json #[email: settings_email password: settings_pass] ø
settings_signup_payload_enc: b64url_json settings_signup_payload
settings_signup: request_json "POST" ("/api/v2/auth/signup/" ++ settings_client_id ++ "/" ++ settings_csrf ++ "/" ++ settings_signup_payload_enc)
check_http_status settings_signup 200 "settings user signup status"
assert_json_ok settings_signup "settings user signup json"

settings_login_payload: write.json #[email: settings_email password: settings_pass] ø
settings_login_payload_enc: b64url_json settings_login_payload
settings_login: request_json "POST" ("/api/v2/auth/login/" ++ settings_client_id ++ "/" ++ settings_csrf ++ "/" ++ settings_login_payload_enc)
check_http_status settings_login 200 "settings user login status"
assert_json_ok settings_login "settings user login json"
settings_token: ""
if all? @[settings_login\json_ok key? settings_login\json "ok" settings_login\json\ok key? settings_login\json "data"] [
    settings_token: to :string settings_login\json\data\token
][
    if settings_login\json_ok [
        if not? settings_login\json\ok [
            mark_fail "settings user login" (to :string settings_login\json\error\message)
        ]
    ]
]
assert_true (not? equal? settings_token "") "settings user token present" "missing settings token"

if not? equal? settings_token "" [
    settings_headers: @[
        #[name: "x-auth-token" value: settings_token]
    ]
    aset: request_json_with_headers "POST" "/api/ai/settings/echo/echo-v1/0.4/0.9/64" settings_headers
    check_http_status aset 200 "ai settings save status"
    assert_json_ok aset "ai settings save json"
    if aset\json_ok [
        assert_true aset\json\ok "ai settings save ok=true" "save failed"
    ]

    aget: request_json_with_headers "GET" "/api/ai/settings" settings_headers
    check_http_status aget 200 "ai settings load status"
    assert_json_ok aget "ai settings load json"
    if aget\json_ok [
        assert_true (equal? aget\json\data\provider "echo") "ai settings provider=echo" "provider mismatch"
        assert_true (equal? aget\json\data\model "echo-v1") "ai settings model=echo-v1" "model mismatch"
    ]
]

; 6) AI chat + options
echo1: request_json "POST" "/api/ai/chat/echo/echo-v1/0.4/hello%20vista"
check_http_status echo1 200 "ai chat echo status"
assert_json_ok echo1 "ai chat echo json"
if all? @[echo1\json_ok key? echo1\json "ok" echo1\json\ok] [
    assert_true echo1\json\ok "ai chat echo ok=true" "echo call failed"
    if key? echo1\json "data" [
        assert_contains_text (to :string echo1\json\data\text) "echo: hello vista" "ai chat echo text"
    ]
][
    if echo1\json_ok [
        if not? echo1\json\ok [
            mark_fail "ai chat echo" (to :string echo1\json\error\message)
        ]
    ]
]

echo2: request_json "POST" "/api/ai/chat/echo/echo-v1/0.4/0.9/32/hello%20options"
check_http_status echo2 200 "ai chat options status"
assert_json_ok echo2 "ai chat options json"
if echo2\json_ok [
    if notEqual? echo2\json null [
        if all? @[key? echo2\json "ok" echo2\json\ok key? echo2\json "data"] [
            echo2_opts: echo2\json\data\raw\options
            assert_true (equal? to :string echo2_opts\top_p "0.9") "ai chat options includes top_p" "top_p mismatch"
            assert_true (equal? to :string echo2_opts\max_tokens "32") "ai chat options includes max_tokens" "max_tokens mismatch"
        ]
    ]
]

; 7) AI error path
bad_provider: request_json "POST" "/api/ai/chat/kilo/kilo-chat-1/0.4/ping"
check_http_status bad_provider 200 "ai unsupported provider status"
assert_json_ok bad_provider "ai unsupported provider json"
if bad_provider\json_ok [
    assert_true (not? bad_provider\json\ok) "ai unsupported provider ok=false" "expected error payload"
    assert_contains_text (to :string bad_provider\json\error\message) "Unsupported provider" "ai unsupported provider message"
]

; 8) JSONP endpoints (disabled by default)
jp_providers: http_request "GET" "/api/ai/providers-script/r_smoke_1"
check_http_status jp_providers 200 "jsonp providers status"
assert_contains_text jp_providers\body "__vistaAiJsonp(" "jsonp providers callback shape"
assert_contains_text jp_providers\body "\"ok\": true" "jsonp providers payload ok"
assert_contains_text jp_providers\body "\"openai\"" "jsonp providers include openai"

jp_chat: http_request "GET" "/api/ai/chat-script/r_smoke_2/echo/echo-v1/0.2/hello%20jsonp"
check_http_status jp_chat 200 "jsonp chat status"
assert_contains_text jp_chat\body "__vistaAiJsonp(" "jsonp chat callback shape"
assert_contains_text jp_chat\body "\"ok\": true" "jsonp chat payload ok"
assert_contains_text jp_chat\body "echo: hello jsonp" "jsonp chat echo text"

print ""
print ["API smoke summary:" stats\pass_count "passed," stats\fail_count "failed"]

if greater? stats\fail_count 0 [
    exit 1
]
