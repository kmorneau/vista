; Pure Arturo API smoke/assert test suite.
; Usage:
;   arturo tests/api-smoke.art
;   arturo tests/api-smoke.art --base=http://localhost:18969

base_url: "http://localhost:18969"
args_vals: args\values
args_len: size args_vals
i: 0
while [less? i args_len][
    arg: to :string (get args_vals i)
    if all? @[greater? (size arg) 7 equal? (slice arg 0 7) "--base="] [
        base_url: slice arg 7 (size arg)
    ]
    i: i + 1
]

stats: #[
    pass_count: 0
    fail_count: 0
]

mark_pass: function [label] [
    stats\pass_count: stats\pass_count + 1
    print ["PASS" label]
]

mark_fail: function [label detail] [
    stats\fail_count: stats\fail_count + 1
    print ["FAIL" label "-" detail]
]

assert_true: function [cond label detail] [
    if cond [
        mark_pass label
    ]
    if not? cond [
        mark_fail label detail
    ]
]

http_request: function [method path] [
    url: base_url ++ path
    cmd: "curl -sS -X " ++ method ++ " \"" ++ url ++ "\" -w \"\\n__STATUS__:%{http_code}\""
    res: execute.code cmd
    if not? equal? res\code 0 [
        return #[
            ok: false
            status: 0
            body: to :string res\output
            error: "curl_failed"
        ]
    ]
    raw: to :string res\output
    marker: "\n__STATUS__:"
    pos: index raw marker
    if equal? pos null [
        return #[
            ok: false
            status: 0
            body: raw
            error: "missing_status_marker"
        ]
    ]
    body: slice raw 0 pos
    status_raw: strip slice raw (pos + size marker) (size raw)
    status_num: 0
    if error? err: <= try [
        status_num: to :integer status_raw
    ] [
        status_num: 0
    ]
    #[
        ok: true
        status: status_num
        body: body
        error: ""
    ]
]

parse_json_safe: function [text] [
    parsed: null
    if error? err: <= try [
        parsed: read.json text
    ] [
        return #[
            ok: false
            data: null
            error: to :string err
        ]
    ]
    #[
        ok: true
        data: parsed
        error: ""
    ]
]

b64url_json: function [jsonText] [
    t: encode.base64 jsonText
    t: replace t "+" "-"
    t: replace t "/" "_"
    replace t "=" ""
]

request_json: function [method path] [
    resp: http_request method path
    if not? resp\ok [
        return #[
            ok: false
            status: resp\status
            body: resp\body
            json_ok: false
            json: null
            error: resp\error
        ]
    ]
    parsed: parse_json_safe resp\body
    #[
        ok: true
        status: resp\status
        body: resp\body
        json_ok: parsed\ok
        json: parsed\data
        error: parsed\error
    ]
]

request_json_with_headers: function [method path headerPairs] [
    url: base_url ++ path
    cmd: "curl -sS -X " ++ method ++ " \"" ++ url ++ "\""
    if notEqual? (type headerPairs) :block [
        headerPairs: []
    ]
    i: 0
    hlen: size headerPairs
    while [less? i hlen] [
        h: get headerPairs i
        if all? @[equal? (type h) :dictionary key? h "name" key? h "value"] [
            cmd: cmd ++ " -H \"" ++ (to :string h\name) ++ ": " ++ (to :string h\value) ++ "\""
        ]
        i: i + 1
    ]
    cmd: cmd ++ " -w \"\\n__STATUS__:%{http_code}\""
    res: execute.code cmd
    if not? equal? res\code 0 [
        return #[
            ok: false
            status: 0
            body: to :string res\output
            error: "curl_failed"
            json_ok: false
            json: null
        ]
    ]
    raw: to :string res\output
    marker: "\n__STATUS__:"
    pos: index raw marker
    if equal? pos null [
        return #[
            ok: false
            status: 0
            body: raw
            error: "missing_status_marker"
            json_ok: false
            json: null
        ]
    ]
    body: slice raw 0 pos
    status_raw: strip slice raw (pos + size marker) (size raw)
    status_num: 0
    if error? err: <= try [
        status_num: to :integer status_raw
    ] [
        status_num: 0
    ]
    parsed: parse_json_safe body
    #[
        ok: true
        status: status_num
        body: body
        json_ok: parsed\ok
        json: parsed\data
        error: parsed\error
    ]
]

request_json_with_body: function [method path bodyText headerPairs] [
    url: base_url ++ path
    cmd: "curl -sS -X " ++ method ++ " \"" ++ url ++ "\" -H 'Content-Type: application/json'"
    if notEqual? (type headerPairs) :block [
        headerPairs: []
    ]
    i: 0
    hlen: size headerPairs
    while [less? i hlen] [
        h: get headerPairs i
        if all? @[equal? (type h) :dictionary key? h "name" key? h "value"] [
            cmd: cmd ++ " -H \"" ++ (to :string h\name) ++ ": " ++ (to :string h\value) ++ "\""
        ]
        i: i + 1
    ]
    cmd: cmd ++ " --data '" ++ bodyText ++ "' -w \"\\n__STATUS__:%{http_code}\""
    res: execute.code cmd
    if not? equal? res\code 0 [
        return #[
            ok: false
            status: 0
            body: to :string res\output
            error: "curl_failed"
            json_ok: false
            json: null
        ]
    ]
    raw: to :string res\output
    marker: "\n__STATUS__:"
    pos: index raw marker
    if equal? pos null [
        return #[
            ok: false
            status: 0
            body: raw
            error: "missing_status_marker"
            json_ok: false
            json: null
        ]
    ]
    body: slice raw 0 pos
    status_raw: strip slice raw (pos + size marker) (size raw)
    status_num: 0
    if error? err: <= try [
        status_num: to :integer status_raw
    ] [
        status_num: 0
    ]
    parsed: parse_json_safe body
    #[
        ok: true
        status: status_num
        body: body
        json_ok: parsed\ok
        json: parsed\data
        error: parsed\error
    ]
]

check_http_status: function [resp expected label] [
    expected_s: to :string expected
    actual_s: to :string resp\status
    detail: "expected " ++ expected_s ++ ", got " ++ actual_s
    assert_true (equal? resp\status expected) label detail
]

assert_json_ok: function [resp label] [
    assert_true resp\json_ok label (resp\error)
]

assert_contains_text: function [hay needle label] [
    assert_true (contains? hay needle) label ("missing: " ++ needle)
]

assert_is_unauthorized: function [resp label] [
    is401: equal? resp\status 401
    hasCode: false
    if all? @[resp\json_ok key? resp\json "error"] [
        errObj: resp\json\error
        if all? @[dictionary? errObj key? errObj "code"] [
            hasCode: equal? to :string errObj\code "unauthorized"
        ]
    ]
    statusText: to :string resp\status
    bodyText: to :string resp\body
    detail: "got status=" ++ statusText ++ ", body=" ++ bodyText
    assert_true (or? is401 hasCode) label detail
]

http_headers_only: function [path] [
    url: base_url ++ path
    cmd: "curl -sS -D - -o /dev/null \"" ++ url ++ "\""
    res: execute.code cmd
    if not? equal? res\code 0 [
        return ""
    ]
    lower to :string res\output
]

print ["API smoke tests against" base_url]

; 1) Health
health: request_json "GET" "/api/health"
check_http_status health 200 "health status"
assert_json_ok health "health json"
if health\json_ok [
    assert_true health\json\ok "health ok=true" "ok flag false"
    assert_true (equal? health\json\data\status "up") "health status=up" "unexpected service status"
]
health_headers: http_headers_only "/api/health"
security_headers: request_json "GET" "/api/security/headers"
check_http_status security_headers 200 "security headers endpoint status"
assert_json_ok security_headers "security headers endpoint json"
if security_headers\json_ok [
    assert_true (key? security_headers\json\data "X-Frame-Options") "security headers include x-frame-options" "missing X-Frame-Options"
    assert_true (key? security_headers\json\data "X-Content-Type-Options") "security headers include x-content-type-options" "missing X-Content-Type-Options"
    assert_true (key? security_headers\json\data "Content-Security-Policy") "security headers include csp" "missing Content-Security-Policy"
]

; 2) Providers
providers: request_json "GET" "/api/ai/providers"
check_http_status providers 200 "providers status"
assert_json_ok providers "providers json"
if providers\json_ok [
    assert_true providers\json\ok "providers ok=true" "ok flag false"
    pdata: providers\json\data
    assert_true (key? pdata "openai") "providers include openai" "openai missing"
    assert_true (key? pdata "gemini") "providers include gemini" "gemini missing"
    assert_true (key? pdata "echo") "providers include echo" "echo missing"
]

; 3) Users (current server exposes GET index only)
users_idx: request_json "GET" "/api/users"
check_http_status users_idx 200 "users index status"
assert_json_ok users_idx "users index json"
if users_idx\json_ok [
    assert_true users_idx\json\ok "users index ok=true" "ok flag false"
]

; 4) Auth v2 (path-encoded payload routes)
stamp: strip execute "date +%s"
auth_email: "auth" ++ stamp ++ "@example.com"
auth_pass: "Password123abc"
auth_client_id: "smoke-client-" ++ stamp

csrf_resp: request_json "GET" ("/api/v2/security/csrf/" ++ auth_client_id)
check_http_status csrf_resp 200 "auth csrf status"
assert_json_ok csrf_resp "auth csrf json"
auth_csrf: ""
if csrf_resp\json_ok [
    auth_csrf: to :string csrf_resp\json\data\token
]
assert_true (not? equal? auth_csrf "") "auth csrf token present" "missing csrf token"

asign_payload: write.json #[email: auth_email password: auth_pass] ø
asign_payload_enc: b64url_json asign_payload
asign: request_json "POST" ("/api/v2/auth/signup/" ++ auth_client_id ++ "/" ++ auth_csrf ++ "/" ++ asign_payload_enc)
check_http_status asign 200 "auth signup status"
assert_json_ok asign "auth signup json"
if asign\json_ok [
    assert_true asign\json\ok "auth signup ok=true" "signup failed"
]

alogin_payload: write.json #[email: auth_email password: auth_pass] ø
alogin_payload_enc: b64url_json alogin_payload
alogin: request_json "POST" ("/api/v2/auth/login/" ++ auth_client_id ++ "/" ++ auth_csrf ++ "/" ++ alogin_payload_enc)
check_http_status alogin 200 "auth login status"
assert_json_ok alogin "auth login json"
token1: ""
if alogin\json_ok [
    if notEqual? alogin\json null [
        if all? @[key? alogin\json "ok" alogin\json\ok key? alogin\json "data"] [
            if key? alogin\json\data "token" [
                token1: to :string alogin\json\data\token
            ]
        ]
    ]
]
assert_true (not? equal? token1 "") "auth token present" "missing token"

; 5) AI endpoints supported by current server
providers_v2: request_json "GET" "/api/v2/ai/providers"
check_http_status providers_v2 200 "providers v2 status"
assert_json_ok providers_v2 "providers v2 json"

aget: request_json "GET" "/api/ai/settings"
check_http_status aget 200 "ai settings load status"
assert_json_ok aget "ai settings load json"

echo_payload: write.json #[
    provider: "echo"
    model: "echo-v1"
    prompt: "hello vista"
    temperature: 0.4
] ø
echo_payload_enc: b64url_json echo_payload
echo_v2: request_json "POST" ("/api/v2/ai/chat/" ++ auth_client_id ++ "/" ++ auth_csrf ++ "/" ++ echo_payload_enc)
check_http_status echo_v2 200 "ai chat v2 echo status"
assert_json_ok echo_v2 "ai chat v2 echo json"
if all? @[echo_v2\json_ok key? echo_v2\json "ok" echo_v2\json\ok key? echo_v2\json "data"] [
    assert_contains_text (to :string echo_v2\json\data\text) "echo: hello vista" "ai chat v2 echo text"
]

print ""
print ["API smoke summary:" stats\pass_count "passed," stats\fail_count "failed"]

if greater? stats\fail_count 0 [
    exit 1
]
