; Pure Arturo API smoke/assert test suite.
; Usage:
;   arturo tests/api-smoke.art
;   arturo tests/api-smoke.art --base=http://localhost:18969

base_url: "http://localhost:18969"
args_vals: args\values
args_len: size args_vals
i: 0
while [less? i args_len][
    arg: to :string (get args_vals i)
    if all? @[greater? (size arg) 7 equal? (slice arg 0 7) "--base="] [
        base_url: slice arg 7 (size arg)
    ]
    i: i + 1
]

stats: #[
    pass_count: 0
    fail_count: 0
]

mark_pass: function [label] [
    stats\pass_count: stats\pass_count + 1
    print ["PASS" label]
]

mark_fail: function [label detail] [
    stats\fail_count: stats\fail_count + 1
    print ["FAIL" label "-" detail]
]

assert_true: function [cond label detail] [
    if cond [
        mark_pass label
    ]
    if not? cond [
        mark_fail label detail
    ]
]

http_request: function [method path] [
    url: base_url ++ path
    cmd: "curl -sS -X " ++ method ++ " \"" ++ url ++ "\" -w \"\\n__STATUS__:%{http_code}\""
    res: execute.code cmd
    if not? equal? res\code 0 [
        return #[
            ok: false
            status: 0
            body: to :string res\output
            error: "curl_failed"
        ]
    ]
    raw: to :string res\output
    marker: "\n__STATUS__:"
    pos: index raw marker
    if equal? pos null [
        return #[
            ok: false
            status: 0
            body: raw
            error: "missing_status_marker"
        ]
    ]
    body: slice raw 0 pos
    status_raw: strip slice raw (pos + size marker) (size raw)
    status_num: 0
    if error? err: <= try [
        status_num: to :integer status_raw
    ] [
        status_num: 0
    ]
    #[
        ok: true
        status: status_num
        body: body
        error: ""
    ]
]

parse_json_safe: function [text] [
    parsed: null
    if error? err: <= try [
        parsed: read.json text
    ] [
        return #[
            ok: false
            data: null
            error: to :string err
        ]
    ]
    #[
        ok: true
        data: parsed
        error: ""
    ]
]

request_json: function [method path] [
    resp: http_request method path
    if not? resp\ok [
        return #[
            ok: false
            status: resp\status
            body: resp\body
            json_ok: false
            json: null
            error: resp\error
        ]
    ]
    parsed: parse_json_safe resp\body
    #[
        ok: true
        status: resp\status
        body: resp\body
        json_ok: parsed\ok
        json: parsed\data
        error: parsed\error
    ]
]

request_json_with_headers: function [method path headerPairs] [
    url: base_url ++ path
    cmd: "curl -sS -X " ++ method ++ " \"" ++ url ++ "\""
    if notEqual? (type headerPairs) :block [
        headerPairs: []
    ]
    i: 0
    hlen: size headerPairs
    while [less? i hlen] [
        h: get headerPairs i
        if all? @[equal? (type h) :dictionary key? h "name" key? h "value"] [
            cmd: cmd ++ " -H \"" ++ (to :string h\name) ++ ": " ++ (to :string h\value) ++ "\""
        ]
        i: i + 1
    ]
    cmd: cmd ++ " -w \"\\n__STATUS__:%{http_code}\""
    res: execute.code cmd
    if not? equal? res\code 0 [
        return #[
            ok: false
            status: 0
            body: to :string res\output
            error: "curl_failed"
            json_ok: false
            json: null
        ]
    ]
    raw: to :string res\output
    marker: "\n__STATUS__:"
    pos: index raw marker
    if equal? pos null [
        return #[
            ok: false
            status: 0
            body: raw
            error: "missing_status_marker"
            json_ok: false
            json: null
        ]
    ]
    body: slice raw 0 pos
    status_raw: strip slice raw (pos + size marker) (size raw)
    status_num: 0
    if error? err: <= try [
        status_num: to :integer status_raw
    ] [
        status_num: 0
    ]
    parsed: parse_json_safe body
    #[
        ok: true
        status: status_num
        body: body
        json_ok: parsed\ok
        json: parsed\data
        error: parsed\error
    ]
]

request_json_with_body: function [method path bodyText headerPairs] [
    url: base_url ++ path
    cmd: "curl -sS -X " ++ method ++ " \"" ++ url ++ "\" -H 'Content-Type: application/json'"
    if notEqual? (type headerPairs) :block [
        headerPairs: []
    ]
    i: 0
    hlen: size headerPairs
    while [less? i hlen] [
        h: get headerPairs i
        if all? @[equal? (type h) :dictionary key? h "name" key? h "value"] [
            cmd: cmd ++ " -H \"" ++ (to :string h\name) ++ ": " ++ (to :string h\value) ++ "\""
        ]
        i: i + 1
    ]
    cmd: cmd ++ " --data '" ++ bodyText ++ "' -w \"\\n__STATUS__:%{http_code}\""
    res: execute.code cmd
    if not? equal? res\code 0 [
        return #[
            ok: false
            status: 0
            body: to :string res\output
            error: "curl_failed"
            json_ok: false
            json: null
        ]
    ]
    raw: to :string res\output
    marker: "\n__STATUS__:"
    pos: index raw marker
    if equal? pos null [
        return #[
            ok: false
            status: 0
            body: raw
            error: "missing_status_marker"
            json_ok: false
            json: null
        ]
    ]
    body: slice raw 0 pos
    status_raw: strip slice raw (pos + size marker) (size raw)
    status_num: 0
    if error? err: <= try [
        status_num: to :integer status_raw
    ] [
        status_num: 0
    ]
    parsed: parse_json_safe body
    #[
        ok: true
        status: status_num
        body: body
        json_ok: parsed\ok
        json: parsed\data
        error: parsed\error
    ]
]

check_http_status: function [resp expected label] [
    expected_s: to :string expected
    actual_s: to :string resp\status
    detail: "expected " ++ expected_s ++ ", got " ++ actual_s
    assert_true (equal? resp\status expected) label detail
]

assert_json_ok: function [resp label] [
    assert_true resp\json_ok label (resp\error)
]

assert_contains_text: function [hay needle label] [
    assert_true (contains? hay needle) label ("missing: " ++ needle)
]

assert_is_unauthorized: function [resp label] [
    is401: equal? resp\status 401
    hasCode: false
    if all? @[resp\json_ok key? resp\json "error"] [
        errObj: resp\json\error
        if all? @[dictionary? errObj key? errObj "code"] [
            hasCode: equal? to :string errObj\code "unauthorized"
        ]
    ]
    statusText: to :string resp\status
    bodyText: to :string resp\body
    detail: "got status=" ++ statusText ++ ", body=" ++ bodyText
    assert_true (or? is401 hasCode) label detail
]

http_headers_only: function [path] [
    url: base_url ++ path
    cmd: "curl -sS -D - -o /dev/null \"" ++ url ++ "\""
    res: execute.code cmd
    if not? equal? res\code 0 [
        return ""
    ]
    lower to :string res\output
]

print ["API smoke tests against" base_url]

; 1) Health
health: request_json "GET" "/api/health"
check_http_status health 200 "health status"
assert_json_ok health "health json"
if health\json_ok [
    assert_true health\json\ok "health ok=true" "ok flag false"
    assert_true (equal? health\json\data\status "up") "health status=up" "unexpected service status"
]
health_headers: http_headers_only "/api/health"
assert_contains_text health_headers "x-frame-options: deny" "health header x-frame-options"
assert_contains_text health_headers "x-content-type-options: nosniff" "health header x-content-type-options"
assert_contains_text health_headers "content-security-policy:" "health header csp"

; 2) Providers
providers: request_json "GET" "/api/ai/providers"
check_http_status providers 200 "providers status"
assert_json_ok providers "providers json"
if providers\json_ok [
    assert_true providers\json\ok "providers ok=true" "ok flag false"
    pdata: providers\json\data
    assert_true (key? pdata "openai") "providers include openai" "openai missing"
    assert_true (key? pdata "gemini") "providers include gemini" "gemini missing"
    assert_true (key? pdata "echo") "providers include echo" "echo missing"
]

; 3) Users CRUD
stamp: strip execute "date +%s"
user_name: "smoke_user_" ++ stamp
user_email: "smoke" ++ stamp ++ "@example.com"
user_email2: "smoke" ++ stamp ++ "_u@example.com"

ucreate: request_json "POST" ("/api/users/" ++ user_name ++ "/" ++ user_email)
check_http_status ucreate 200 "users create status"
assert_json_ok ucreate "users create json"
user_id: ""
if ucreate\json_ok [
    user_id: to :string ucreate\json\data\id
    assert_true (not? equal? user_id "") "users create id present" "missing user id"
]

if not? equal? user_id "" [
    ushow: request_json "GET" ("/api/users/" ++ user_id)
    check_http_status ushow 200 "users show status"
    assert_json_ok ushow "users show json"

    uupdate: request_json "PUT" ("/api/users/" ++ user_id ++ "/updated_" ++ stamp ++ "/" ++ user_email2)
    check_http_status uupdate 200 "users update status"
    assert_json_ok uupdate "users update json"

    udelete: http_request "DELETE" ("/api/users/" ++ user_id)
    check_http_status udelete 200 "users delete status"
]

; 4) Auth + MFA
auth_email: "auth" ++ stamp ++ "@example.com"
auth_pass: "Password123abc"
auth_pass2: "Password456xyz"
auth_email2: "auth" ++ stamp ++ "_new@example.com"
auth_client_id: "smoke-client-" ++ stamp
auth_headers: @[
    #[name: "x-client-id" value: auth_client_id]
]

csrf_resp: request_json "GET" ("/api/v2/security/csrf/" ++ auth_client_id)
check_http_status csrf_resp 200 "auth csrf status"
assert_json_ok csrf_resp "auth csrf json"
auth_csrf: ""
if csrf_resp\json_ok [
    auth_csrf: to :string csrf_resp\json\data\token
    assert_true (not? equal? auth_csrf "") "auth csrf token present" "missing csrf token"
]
auth_headers: auth_headers ++ @[
    #[name: "x-csrf-token" value: auth_csrf]
]

asign_payload: write.json #[email: auth_email password: auth_pass] ø
asign: request_json_with_body "POST" "/api/v2/auth/signup" asign_payload auth_headers
check_http_status asign 200 "auth signup status"
assert_json_ok asign "auth signup json"

alogin_payload: write.json #[email: auth_email password: auth_pass] ø
alogin: request_json_with_body "POST" "/api/v2/auth/login" alogin_payload auth_headers
check_http_status alogin 200 "auth login status"
assert_json_ok alogin "auth login json"

token1: ""
if alogin\json_ok [
    token1: to :string alogin\json\data\token
    assert_true (not? equal? token1 "") "auth token present" "missing token"
]

if not? equal? token1 "" [
    me_headers: auth_headers ++ @[
        #[name: "x-auth-token" value: token1]
    ]
    ame: request_json_with_headers "GET" "/api/v2/auth/me" me_headers
    check_http_status ame 200 "auth me status"
    assert_json_ok ame "auth me json"
    if ame\json_ok [
        assert_true (equal? ame\json\data\role "user") "auth me role=user" "expected user role"
    ]

    aemail_payload: write.json #[token: token1 email: auth_email2] ø
    aemail: request_json_with_body "PUT" "/api/v2/auth/email" aemail_payload auth_headers
    check_http_status aemail 200 "auth update email status"
    assert_json_ok aemail "auth update email json"
    token_email: ""
    if aemail\json_ok [
        if key? aemail\json\data "token" [
            token_email: to :string aemail\json\data\token
        ]
        assert_true (not? equal? token_email "") "auth update email rotated token present" "missing rotated token"
        assert_true (not? equal? token_email token1) "auth update email token changed" "token not rotated"
    ]
    if not? equal? token_email "" [
        old_headers_email: auth_headers ++ @[
            #[name: "x-auth-token" value: token1]
        ]
        ame_old_after_email: request_json_with_headers "GET" "/api/v2/auth/me" old_headers_email
        assert_is_unauthorized ame_old_after_email "auth old token invalid after email update"
        new_headers_email: auth_headers ++ @[
            #[name: "x-auth-token" value: token_email]
        ]
        ame_new_after_email: request_json_with_headers "GET" "/api/v2/auth/me" new_headers_email
        check_http_status ame_new_after_email 200 "auth new token valid after email update"
    ]

    active_token: token1
    if not? equal? token_email "" [
        active_token: token_email
    ]
    apass_payload: write.json #[token: active_token old_password: auth_pass new_password: auth_pass2] ø
    apass: request_json_with_body "PUT" "/api/v2/auth/password" apass_payload auth_headers
    check_http_status apass 200 "auth update password status"
    assert_json_ok apass "auth update password json"
    token_pass: ""
    if apass\json_ok [
        if key? apass\json\data "token" [
            token_pass: to :string apass\json\data\token
        ]
        assert_true (not? equal? token_pass "") "auth update password rotated token present" "missing rotated token"
        assert_true (not? equal? token_pass active_token) "auth update password token changed" "token not rotated"
    ]
    if all? @[not? equal? token_pass "" not? equal? active_token ""] [
        old_headers_pass: auth_headers ++ @[
            #[name: "x-auth-token" value: active_token]
        ]
        ame_old_after_pass: request_json_with_headers "GET" "/api/v2/auth/me" old_headers_pass
        assert_is_unauthorized ame_old_after_pass "auth old token invalid after password update"
        new_headers_pass: auth_headers ++ @[
            #[name: "x-auth-token" value: token_pass]
        ]
        ame_new_after_pass: request_json_with_headers "GET" "/api/v2/auth/me" new_headers_pass
        check_http_status ame_new_after_pass 200 "auth new token valid after password update"
    ]
    if not? equal? token_pass "" [
        active_token: token_pass
    ]

    mfa_enable_headers: auth_headers ++ @[
        #[name: "x-auth-token" value: active_token]
    ]
    aenable: request_json_with_headers "POST" "/api/v2/auth/mfa/enable" mfa_enable_headers
    check_http_status aenable 200 "auth enable mfa status"
    assert_json_ok aenable "auth enable mfa json"

    alogout1_payload: write.json #[token: active_token] ø
    alogout1: request_json_with_body "POST" "/api/v2/auth/logout" alogout1_payload auth_headers
    check_http_status alogout1 200 "auth logout status"
    assert_json_ok alogout1 "auth logout json"
    if alogout1\json_ok [
        assert_true alogout1\json\data\revoked "auth logout revoked=true" "session not revoked"
    ]
    execute "sleep 0.1"

    post_logout_headers: auth_headers ++ @[
        #[name: "x-auth-token" value: active_token]
    ]
    ame2: request_json_with_headers "GET" "/api/v2/auth/me" post_logout_headers
    assert_is_unauthorized ame2 "auth me after logout unauthorized"

    alogin2_payload: write.json #[email: auth_email2 password: auth_pass2] ø
    alogin2: request_json_with_body "POST" "/api/v2/auth/login" alogin2_payload auth_headers
    check_http_status alogin2 200 "auth login mfa-required status"
    assert_json_ok alogin2 "auth login mfa-required json"

    challenge: ""
    if alogin2\json_ok [
        challenge: to :string alogin2\json\data\challenge_id
        assert_true (not? equal? challenge "") "auth login challenge present" "missing challenge_id"
        assert_true (key? alogin2\json\data "expires_in") "auth login mfa expires_in present" "missing expires_in"
    ]

    assert_true true "auth mfa verify skipped (no OTP echo)" "mfa verification requires external OTP delivery"
]

legacy_login: request_json "POST" ("/api/auth/login/" ++ auth_email2 ++ "/" ++ auth_pass2)
check_http_status legacy_login 404 "legacy auth login status"

; 5) AI settings roundtrip (authenticated)
settings_email: "settings" ++ stamp ++ "@example.com"
settings_pass: "SettingsPass123"
settings_signup_payload: write.json #[email: settings_email password: settings_pass] ø
settings_signup: request_json_with_body "POST" "/api/v2/auth/signup" settings_signup_payload auth_headers
check_http_status settings_signup 200 "settings user signup status"
assert_json_ok settings_signup "settings user signup json"

settings_login_payload: write.json #[email: settings_email password: settings_pass] ø
settings_login: request_json_with_body "POST" "/api/v2/auth/login" settings_login_payload auth_headers
check_http_status settings_login 200 "settings user login status"
assert_json_ok settings_login "settings user login json"
settings_token: ""
if settings_login\json_ok [
    settings_token: to :string settings_login\json\data\token
]
assert_true (not? equal? settings_token "") "settings user token present" "missing settings token"

if not? equal? settings_token "" [
    settings_headers: @[
        #[name: "x-auth-token" value: settings_token]
    ]
    aset: request_json_with_headers "POST" "/api/ai/settings/echo/echo-v1/0.4/0.9/64" settings_headers
    check_http_status aset 200 "ai settings save status"
    assert_json_ok aset "ai settings save json"
    if aset\json_ok [
        assert_true aset\json\ok "ai settings save ok=true" "save failed"
    ]

    aget: request_json_with_headers "GET" "/api/ai/settings" settings_headers
    check_http_status aget 200 "ai settings load status"
    assert_json_ok aget "ai settings load json"
    if aget\json_ok [
        assert_true (equal? aget\json\data\provider "echo") "ai settings provider=echo" "provider mismatch"
        assert_true (equal? aget\json\data\model "echo-v1") "ai settings model=echo-v1" "model mismatch"
    ]
]

; 6) AI chat + options
echo1: request_json "POST" "/api/ai/chat/echo/echo-v1/0.4/hello%20vista"
check_http_status echo1 200 "ai chat echo status"
assert_json_ok echo1 "ai chat echo json"
if echo1\json_ok [
    assert_true echo1\json\ok "ai chat echo ok=true" "echo call failed"
    assert_contains_text (to :string echo1\json\data\text) "echo: hello vista" "ai chat echo text"
]

echo2: request_json "POST" "/api/ai/chat/echo/echo-v1/0.4/0.9/32/hello%20options"
check_http_status echo2 200 "ai chat options status"
assert_json_ok echo2 "ai chat options json"
if echo2\json_ok [
    echo2_opts: echo2\json\data\raw\options
    assert_true (equal? to :string echo2_opts\top_p "0.9") "ai chat options includes top_p" "top_p mismatch"
    assert_true (equal? to :string echo2_opts\max_tokens "32") "ai chat options includes max_tokens" "max_tokens mismatch"
]

; 7) AI error path
bad_provider: request_json "POST" "/api/ai/chat/kilo/kilo-chat-1/0.4/ping"
check_http_status bad_provider 200 "ai unsupported provider status"
assert_json_ok bad_provider "ai unsupported provider json"
if bad_provider\json_ok [
    assert_true (not? bad_provider\json\ok) "ai unsupported provider ok=false" "expected error payload"
    assert_contains_text (to :string bad_provider\json\error\message) "Unsupported provider" "ai unsupported provider message"
]

; 8) JSONP endpoints (disabled by default)
jp_providers: http_request "GET" "/api/ai/providers-script/r_smoke_1"
check_http_status jp_providers 200 "jsonp providers status"
assert_contains_text jp_providers\body "__vistaAiJsonp(" "jsonp providers callback shape"
assert_contains_text jp_providers\body "\"ok\": false" "jsonp providers payload blocked"
assert_contains_text jp_providers\body "Script routes are disabled" "jsonp providers disabled message"

jp_chat: http_request "GET" "/api/ai/chat-script/r_smoke_2/echo/echo-v1/0.2/hello%20jsonp"
check_http_status jp_chat 200 "jsonp chat status"
assert_contains_text jp_chat\body "__vistaAiJsonp(" "jsonp chat callback shape"
assert_contains_text jp_chat\body "\"ok\": false" "jsonp chat payload blocked"
assert_contains_text jp_chat\body "Script routes are disabled" "jsonp chat disabled message"

print ""
print ["API smoke summary:" stats\pass_count "passed," stats\fail_count "failed"]

if greater? stats\fail_count 0 [
    exit 1
]
