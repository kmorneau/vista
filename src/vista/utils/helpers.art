; Vista UI - Helper Functions

js_escape_single: function [s] [
        s: replace s "\\" "\\\\"
        s: replace s "'" "\\'"
        s: replace s "\r" "\\r"
        s: replace s "\n" "\\n"
        s
]

html_escape_attr: function [s] [
        s: replace s "&" "&"
        s: replace s "<" "<"
        s: replace s ">" ">"
        s: replace s "'" "'"
        s: replace s "\"" """
        s
]

html_escape_text: function [s] [
        s: replace s "&" "&"
        s: replace s "<" "<"
        s: replace s ">" ">"
        s
]

logo_data_url: function [pathStr] [
        if any? @[equal? pathStr null equal? pathStr ""] [
                return ""
        ]
        ptype: type pathStr
        if not? equal? ptype :string [
                if any? @[equal? ptype :literal equal? ptype :pathLiteral equal? ptype :path] [
                        pathStr: to :string pathStr
                ] [
                        return ""
                ]
        ]
        if any? @[prefix? pathStr "data:" prefix? pathStr "http://" prefix? pathStr "https://"] [
                return pathStr
        ]
        pathStr
]

is_raw_html: function [value] [
        if equal? (type value) :dictionary [
                if key? value "raw" [
                        return value\raw
                ]
        ]
        false
]

raw: function [content] [
        #[
                raw: true
                value: to :string content
        ]
]

html_text: function [value] [
        if is_raw_html value [
                return value\value
        ]
        html_escape_text (to :string value)
]

normalize_block: function [block] [
        if notEqual? (type block) :block [
                return block
        ]
        out: []
        i: 0
        blen: size block
        while [less? i blen][
                tok: get block i
                tok_type: type tok
                did_combine: false
                if any? @[equal? tok_type :word equal? tok_type :attributeLabel equal? tok_type :attribute] [
                        combinedStr: to :string tok
                        joinStr: "-"
                        if equal? tok_type :word [
                                joinStr: "_"
                        ]
                        j: i
                        saw_label: equal? tok_type :attributeLabel
                        while [less? (j + 2) blen][
                                mid: get block (j + 1)
                                tail: get block (j + 2)
                                tail_type: type tail
                                if not? all? @[equal? (type mid) :symbol equal? (to :string mid) "-" any? @[equal? tail_type :word equal? tail_type :label]] [
                                        break
                                ]
                                combinedStr: combinedStr ++ joinStr ++ (to :string tail)
                                if equal? tail_type :label [
                                        saw_label: true
                                ]
                                j: j + 2
                        ]
                        if greater? j i [
                                combined: null
                                switch equal? tok_type :attribute [
                                        switch saw_label [
                                                combined: to :attributeLabel combinedStr
                                        ][
                                                combined: to :attribute combinedStr
                                        ]
                                ][
                                        switch equal? tok_type :attributeLabel [
                                                combined: to :attributeLabel combinedStr
                                        ][
                                                combined: to :word combinedStr
                                        ]
                                ]
                                out: out ++ @[combined]
                                i: j + 1
                                did_combine: true
                        ]
                ]
                if not? did_combine [
                        out: out ++ @[tok]
                        i: i + 1
                ]
        ]
        out
]

strip_root_div: function [html] [
        if all? @[prefix? html "<div>" suffix? html "</div>"] [
                len: size html
                endIdx: len - 7
                if greaterOrEqual? endIdx 5 [
                        return slice html 5 endIdx
                ]
                return ""
        ]
        html
]

append_value: function [lst val] [
        lst ++ @[val]
]

attrs_to_html: function [attrs] [
        keysList: keys attrs
        keys_len: size keysList
        if equal? keys_len 0 [
                return ""
        ]
        html: ""
        i: 0
        while [less? i keys_len][
                k: get keysList i
                v: attrs\[k]
                v_type: type v
                switch equal? v_type :logical [
                        if v [
                                html: html ++ " " ++ k
                        ]
                ][
                        html: html ++ " " ++ k ++ "='"
                        html: html ++ html_escape_attr (to :string v)
                        html: html ++ "'"
                ]
                i: i + 1
        ]
        html
]

attrs_without: function [attrs key] [
        filtered: #[]
        keysList: keys attrs
        i: 0
        keys_len: size keysList
        while [less? i keys_len][
                k: get keysList i
                if notEqual? k key [
                        filtered\[k]: attrs\[k]
                ]
                i: i + 1
        ]
        filtered
]

take_attr: function [attrs key] [
        val: null
        if key? attrs key [
                val: attrs\[key]
                attrs: attrs_without attrs key
        ]
        #[
                value: val
                attrs: attrs
        ]
]

append_style: function [style fragment] [
        switch equal? style "" [
                fragment
        ][
                style ++ " " ++ fragment
        ]
]

has_style_dim: function [attrs] [
        if key? attrs "style" [
                s: to :string attrs\style
                if notEqual? (find s "width:") null [
                        return true
                ]
                if notEqual? (find s "height:") null [
                        return true
                ]
        ]
        false
]

maybe_autosize_text_attrs: function [attrs] [
        if key? attrs "data-auto-size" [
                return attrs
        ]
        if has_style_dim attrs [
                return attrs
        ]
        attrs\["data-auto-size"]: "text"
        attrs
]

style_value: function [val] [
        t: type val
        switch equal? t :integer [
                valStr: to :string val
                valStr ++ "px"
        ][
                switch equal? t :floating [
                        valStr: to :string val
                        valStr ++ "px"
                ][
                        to :string val
                ]
        ]
]

merge_pending_attrs: function [attrs pending] [
        res: attrs
        keysList: keys pending
        klen: size keysList
        i: 0
        while [less? i klen][
                k: get keysList i
                switch key? res k [
                        if equal? k "class" [
                                res\class: to :string res\class ++ " " ++ to :string pending\class
                        ]
                        if equal? k "style" [
                                res\style: append_style (to :string res\style) (to :string pending\style)
                        ]
                ][
                        res\[k]: pending\[k]
                ]
                i: i + 1
        ]
        res
]

merge_layout_scopes: function [attrs] [
        res: attrs
        stackLen: size vista_state\layout_scope_stack
        i: 0
        while [less? i stackLen][
                res: merge_pending_attrs res (get vista_state\layout_scope_stack i)
                i: i + 1
        ]
        res
]

merge_class_attr: function [attrs baseClass] [
        if notEqual? (type attrs) :dictionary [
                attrs: #[]
        ]
        classVal: baseClass
        if key? attrs "class" [
                classVal: baseClass ++ " " ++ to :string attrs\class
        ]
        rest: attrs_without attrs "class"
        #[
                class: classVal
                attrs: rest
        ]
]

js_literal: function [value] [
        t: type value
        switch equal? t :string [
                escaped: js_escape_single value
                out: "'"
                out: out ++ escaped
                out: out ++ "'"
                out
        ][
                switch equal? t :integer [
                        to :string value
                ][
                        switch equal? t :floating [
                                to :string value
                        ][
                                switch equal? t :logical [
                                        to :string value
                                ][
                                        switch equal? t :null [
                                                "null"
                                        ][
                                                escaped: js_escape_single (to :string value)
                                                out: "'"
                                                out: out ++ escaped
                                                out: out ++ "'"
                                                out
                                        ]
                                ]
                        ]
                ]
        ]
]

json_escape: function [value] [
        out: ""
        s: to :string value
        i: 0
        len: size s
        while [less? i len][
                ch: get s i
                escaped: false
                if equal? ch "\\" [
                        out: out ++ "\\\\"
                        escaped: true
                ]
                if equal? ch "\"" [
                        out: out ++ "\\\""
                        escaped: true
                ]
                if equal? ch "\n" [
                        out: out ++ "\\n"
                        escaped: true
                ]
                if equal? ch "\r" [
                        out: out ++ "\\r"
                        escaped: true
                ]
                if equal? ch "\t" [
                        out: out ++ "\\t"
                        escaped: true
                ]
                if not? escaped [
                        out: out ++ ch
                ]
                i: i + 1
        ]
        out
]

json_encode: function [value] [
        t: type value
        switch equal? t :string [
                "\"" ++ json_escape value ++ "\""
        ][
                switch equal? t :integer [
                        to :string value
                ][
                        switch equal? t :floating [
                                to :string value
                        ][
                                switch equal? t :logical [
                                        switch value [
                                                "true"
                                        ][
                                                "false"
                                        ]
                                ][
                                        switch equal? t :null [
                                                "null"
                                        ][
                                                switch equal? t :dictionary [
                                                        keysList: keys value
                                                        i: 0
                                                        klen: size keysList
                                                        out: "{"
                                                        first: true
                                                        while [less? i klen][
                                                                k: get keysList i
                                                                v: value\[k]
                                                                if not? first [
                                                                        out: out ++ ","
                                                                ]
                                                                out: out ++ "\"" ++ json_escape k ++ "\":" ++ json_encode v
                                                                first: false
                                                                i: i + 1
                                                        ]
                                                        out ++ "}"
                                                ][
                                                        switch equal? t :block [
                                                                i: 0
                                                                blen: size value
                                                                out: "["
                                                                first: true
                                                                while [less? i blen][
                                                                        item: get value i
                                                                        if not? first [
                                                                                out: out ++ ","
                                                                        ]
                                                                        out: out ++ json_encode item
                                                                        first: false
                                                                        i: i + 1
                                                                ]
                                                                out ++ "]"
                                                        ][
                                                                "\"" ++ json_escape (to :string value) ++ "\""
                                                        ]
                                                ]
                                        ]
                                ]
                        ]
                ]
        ]
]

json_pretty: function [json] [
        indent: 0
        inString: false
        escapeNext: false
        out: ""
        len: size json
        i: 0
        while [less? i len][
                ch: get json i
                if escapeNext [
                        out: out ++ ch
                        escapeNext: false
                        i: i + 1
                        continue
                ]
                if equal? ch "\\" [
                        out: out ++ ch
                        if inString [ escapeNext: true ]
                        i: i + 1
                        continue
                ]
                if equal? ch "\"" [
                        inString: not inString
                        out: out ++ ch
                        i: i + 1
                        continue
                ]
                if inString [
                        out: out ++ ch
                        i: i + 1
                        continue
                ]
                if any? @[equal? ch "{" equal? ch "["] [
                        indent: indent + 1
                        out: out ++ ch ++ "\n" ++ repeat "  " indent
                        i: i + 1
                        continue
                ]
                if any? @[equal? ch "}" equal? ch "]"] [
                        indent: indent - 1
                        out: out ++ "\n" ++ repeat "  " indent ++ ch
                        i: i + 1
                        continue
                ]
                if equal? ch "," [
                        out: out ++ ch ++ "\n" ++ repeat "  " indent
                        i: i + 1
                        continue
                ]
                if equal? ch ":" [
                        out: out ++ ": "
                        i: i + 1
                        continue
                ]
                out: out ++ ch
                i: i + 1
        ]
        out
]

header_value: function [hdr key] [
        keyStr: to :string key
        if key? hdr keyStr [
                return hdr\[keyStr]
        ]
        lowerKey: lower keyStr
        if key? hdr lowerKey [
                return hdr\[lowerKey]
        ]
        null
]

header_from_block: function [blk] [
        hdr: #[]
        if notEqual? (type blk) :block [
                return hdr
        ]
        blen: size blk
        i: 0
        while [less? i blen][
                k: get blk i
                ktype: type k
                handled: false
                if equal? ktype :label [
                        keyStr: to :string k
                        if less? (i + 1) blen [
                                hdr\[keyStr]: get blk (i + 1)
                                i: i + 2
                                handled: true
                        ]
                ]
                if not? handled [
                        i: i + 1
                ]
        ]
        hdr
]
