; Host split: render HTML independently from host delivery side effects.
view_render_html: function [layoutBlock] [
    apply_arturo_header
    vista_state\webview_open: false
    build_full_html layoutBlock
]

view_host_options: function [] [
    noWebview: false
    if attr? "noWebview" [
        noWebview: true
    ]
    env_vars: env
    if key? env_vars "VISTA_NO_WEBVIEW" [
        noWebview: true
    ]
    if key? env_vars "NO_WEBVIEW" [
        noWebview: true
    ]
    filePath: attr "file"
    fileName: "ui.html"
    if notEqual? filePath null [
        fileName: to :string filePath
    ]
    #[
        noWebview: noWebview
        absPath: absolute fileName
    ]
]

view_host_deliver_default: function [fullHtml hostOptions] [
    absPath: hostOptions\absPath
    noWebview: hostOptions\noWebview
    write fullHtml absPath
    if noWebview [
        vista_state\webview_open: false
        return fullHtml
    ]
    safePath: replace absPath "\"" "\\\""
    openCmd: "open \"" ++ safePath ++ "\" >/dev/null 2>&1 &"
    if error? err: <= try [
        execute openCmd
    ] [
        ; If browser launch fails, keep behavior non-blocking and still return HTML.
    ]
    fullHtml
]

; View function: generate full HTML and serve through the default host adapter.
view: function [layoutBlock] [
    fullHtml: view_render_html layoutBlock
    if attr? "returnHtml" [
        return fullHtml
    ]
    hostOptions: view_host_options
    view_host_deliver_default fullHtml hostOptions
]

vid: function [layoutBlock] [
    prev: vista_vid_mode
    vista_vid_mode: true
    result: null
    returnHtml: false
    if attr? "returnHtml" [
        returnHtml: true
    ]
    switch returnHtml [
        result: view .returnHtml layoutBlock
    ][
        switch attr? "file" [
            path: attr "file"
            switch attr? "noWebview" [
                result: view .file:path .noWebview layoutBlock
            ][
                result: view .file:path layoutBlock
            ]
        ][
            switch attr? "noWebview" [
                result: view .noWebview layoutBlock
            ][
                result: view layoutBlock
            ]
        ]
    ]
    vista_vid_mode: prev
    result
]

vista_runtime_webview_inject: function [js] [
    if not? webview_enabled [
        return false
    ]
    if not? vista_state\webview_open [
        return false
    ]
    env_vars: env
    if any? @[key? env_vars "VISTA_NO_WEBVIEW" key? env_vars "NO_WEBVIEW"] [
        return false
    ]
    webview .inject: js ""
    true
]

alert: function [message] [
    msg: to :string message
    js: "window.alert('" ++ js_escape_single msg ++ "');"
    if vista_runtime_webview_inject js [
        return true
    ]
    print msg
    true
]

dialog: function [layoutOrText] [
    if equal? (type layoutOrText) :block [
        innerHtml: layout layoutOrText
        js: "(()=>{var old=document.getElementById('__vistaRuntimeDialog');if(old){old.remove();}var host=document.createElement('div');host.id='__vistaRuntimeDialog';host.style.cssText='position:fixed;inset:0;background:rgba(0,0,0,.38);display:flex;align-items:center;justify-content:center;z-index:99999;padding:18px;';var card=document.createElement('div');card.style.cssText='background:#fff;border:1px solid #ded6c2;border-radius:12px;min-width:320px;max-width:860px;max-height:86vh;overflow:auto;padding:14px;box-shadow:0 18px 40px rgba(0,0,0,.22);';card.innerHTML='" ++ js_escape_single innerHtml ++ "';host.appendChild(card);host.addEventListener('click',function(e){if(e.target===host){host.remove();}});document.body.appendChild(host);})();"
        if vista_runtime_webview_inject js [
            return true
        ]
    ]
    alert layoutOrText
    true
]

clip: function [facePath] [
    value: to :string facePath
    clipTmp: absolute ".vista-clip.tmp"
    write value clipTmp
    safePath: replace clipTmp "\"" "\\\""
    if not? error? err: <= try [
        execute "cat \"" ++ safePath ++ "\" | pbcopy"
    ] [
        return true
    ]
    if not? error? err: <= try [
        execute "cat \"" ++ safePath ++ "\" | xclip -selection clipboard"
    ] [
        return true
    ]
    if not? error? err: <= try [
        execute "cat \"" ++ safePath ++ "\" | wl-copy"
    ] [
        return true
    ]
    false
]

unclip: function [] [
    if not? error? err: <= try [
        return execute "pbpaste"
    ] [
    ]
    if not? error? err: <= try [
        return execute "xclip -selection clipboard -o"
    ] [
    ]
    if not? error? err: <= try [
        return execute "wl-paste"
    ] [
    ]
    ""
]

; Runtime helpers for rate/feel semantics
set_rate: function [faceId rateMs] [
    face: get_face faceId
    if equal? face null [
        return false
    ]
    attrs: face\attrs
    attrs\["data-rate"]: to :string rateMs
    update_face face\id #[attrs: attrs]
    true
]

get_rate: function [faceId] [
    face: get_face faceId
    if equal? face null [
        return null
    ]
    if key? face\attrs "data-rate" [
        return face\attrs\["data-rate"]
    ]
    null
]

clear_rate: function [faceId] [
    face: get_face faceId
    if equal? face null [
        return false
    ]
    attrs: attrs_without face\attrs "data-rate"
    attrs: attrs_without attrs "data-rate-on-tick"
    update_face face\id #[attrs: attrs]
    true
]

apply_feel: function [faceId feelDef] [
    face: get_face faceId
    if any? @[equal? face null notEqual? (type feelDef) :dictionary] [
        return false
    ]
    attrs: face\attrs
    compile: function [v] [
        t: type v
        switch any? @[equal? t :block equal? t :dictionary] [
            vv: v
            if equal? t :dictionary [
                vv: dict_to_block v
            ]
            compile_action vv vista_state\last_bindings
        ][
            to :string v
        ]
    ]
    if key? feelDef "hover" [ attrs\onmouseenter: compile feelDef\["hover"] ]
    if key? feelDef "away" [ attrs\onmouseleave: compile feelDef\["away"] ]
    if key? feelDef "click" [ attrs\onclick: compile feelDef\["click"] ]
    if key? feelDef "down" [ attrs\onmousedown: compile feelDef\["down"] ]
    if key? feelDef "up" [ attrs\onmouseup: compile feelDef\["up"] ]
    if key? feelDef "move" [ attrs\onmousemove: compile feelDef\["move"] ]
    if key? feelDef "input" [ attrs\oninput: compile feelDef\["input"] ]
    if key? feelDef "change" [ attrs\onchange: compile feelDef\["change"] ]
    if key? feelDef "focus" [ attrs\onfocus: compile feelDef\["focus"] ]
    if key? feelDef "blur" [ attrs\onblur: compile feelDef\["blur"] ]
    if key? feelDef "key" [ attrs\onkeydown: compile feelDef\["key"] ]
    if key? feelDef "drag" [ attrs\["data-feel-drag"]: compile feelDef\["drag"] ]
    if key? feelDef "pointer-down" [ attrs\["data-feel-pointer-down"]: compile feelDef\["pointer-down"] ]
    if key? feelDef "pointer_down" [ attrs\["data-feel-pointer-down"]: compile feelDef\pointer_down ]
    if key? feelDef "pointer-move" [ attrs\["data-feel-pointer-move"]: compile feelDef\["pointer-move"] ]
    if key? feelDef "pointer_move" [ attrs\["data-feel-pointer-move"]: compile feelDef\pointer_move ]
    if key? feelDef "pointer-up" [ attrs\["data-feel-pointer-up"]: compile feelDef\["pointer-up"] ]
    if key? feelDef "pointer_up" [ attrs\["data-feel-pointer-up"]: compile feelDef\pointer_up ]
    if key? feelDef "pointer-cancel" [ attrs\["data-feel-pointer-cancel"]: compile feelDef\["pointer-cancel"] ]
    if key? feelDef "pointer_cancel" [ attrs\["data-feel-pointer-cancel"]: compile feelDef\pointer_cancel ]
    if key? feelDef "tap" [ attrs\["data-feel-tap"]: compile feelDef\tap ]
    if key? feelDef "long-press" [ attrs\["data-feel-long-press"]: compile feelDef\["long-press"] ]
    if key? feelDef "long_press" [ attrs\["data-feel-long-press"]: compile feelDef\long_press ]
    if key? feelDef "long-press-ms" [ attrs\["data-feel-long-press-ms"]: to :string feelDef\["long-press-ms"] ]
    if key? feelDef "long_press_ms" [ attrs\["data-feel-long-press-ms"]: to :string feelDef\long_press_ms ]
    if key? feelDef "dragstart" [
        attrs\["data-dnd-dragstart"]: compile feelDef\dragstart
        if not? key? attrs "draggable" [ attrs\draggable: true ]
    ]
    if key? feelDef "dragover" [ attrs\["data-dnd-dragover"]: compile feelDef\dragover ]
    if key? feelDef "drop" [ attrs\["data-dnd-drop"]: compile feelDef\drop ]
    if key? feelDef "dragenter" [ attrs\["data-dnd-dragenter"]: compile feelDef\dragenter ]
    if key? feelDef "dragleave" [ attrs\["data-dnd-dragleave"]: compile feelDef\dragleave ]
    if key? feelDef "dragend" [ attrs\["data-dnd-dragend"]: compile feelDef\dragend ]
    if key? feelDef "drag-data" [ attrs\["data-dnd-payload"]: to :string feelDef\["drag-data"] ]
    if key? feelDef "drag_data" [ attrs\["data-dnd-payload"]: to :string feelDef\drag_data ]
    if key? feelDef "drop-effect" [ attrs\["data-dnd-drop-effect"]: to :string feelDef\["drop-effect"] ]
    if key? feelDef "drop_effect" [ attrs\["data-dnd-drop-effect"]: to :string feelDef\drop_effect ]
    update_face face\id #[attrs: attrs]
    true
]

remove_feel: function [faceId] [
    face: get_face faceId
    if equal? face null [
        return false
    ]
    attrs: face\attrs
    attrs: attrs_without attrs "onmouseenter"
    attrs: attrs_without attrs "onmouseleave"
    attrs: attrs_without attrs "onclick"
    attrs: attrs_without attrs "onmousedown"
    attrs: attrs_without attrs "onmouseup"
    attrs: attrs_without attrs "onmousemove"
    attrs: attrs_without attrs "oninput"
    attrs: attrs_without attrs "onchange"
    attrs: attrs_without attrs "onfocus"
    attrs: attrs_without attrs "onblur"
    attrs: attrs_without attrs "onkeydown"
    attrs: attrs_without attrs "data-feel-drag"
    attrs: attrs_without attrs "data-feel-pointer-down"
    attrs: attrs_without attrs "data-feel-pointer-move"
    attrs: attrs_without attrs "data-feel-pointer-up"
    attrs: attrs_without attrs "data-feel-pointer-cancel"
    attrs: attrs_without attrs "data-feel-tap"
    attrs: attrs_without attrs "data-feel-long-press"
    attrs: attrs_without attrs "data-feel-long-press-ms"
    attrs: attrs_without attrs "data-dnd-dragstart"
    attrs: attrs_without attrs "data-dnd-dragover"
    attrs: attrs_without attrs "data-dnd-drop"
    attrs: attrs_without attrs "data-dnd-dragenter"
    attrs: attrs_without attrs "data-dnd-dragleave"
    attrs: attrs_without attrs "data-dnd-dragend"
    attrs: attrs_without attrs "data-dnd-payload"
    attrs: attrs_without attrs "data-dnd-drop-effect"
    attrs: attrs_without attrs "draggable"
    update_face face\id #[attrs: attrs]
    true
]
